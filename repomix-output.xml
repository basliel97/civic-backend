This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
package.json
README.md
src/config/env.ts
src/index.ts
src/routes/auth.ts
src/services/fyda.ts
src/services/supabase.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# dev
.yarn/
!.yarn/releases
.vscode/*
!.vscode/launch.json
!.vscode/*.code-snippets
.idea/workspace.xml
.idea/usage.statistics.xml
.idea/shelf

# deps
node_modules/

# env
.env
.env.production

# logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# misc
.DS_Store
</file>

<file path="package.json">
{
  "name": "civic-backend",
  "type": "module",
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js"
  },
  "dependencies": {
    "@hono/node-server": "^1.19.6",
    "@supabase/supabase-js": "^2.86.0",
    "axios": "^1.13.2",
    "dotenv": "^17.2.3",
    "hono": "^4.10.7"
  },
  "devDependencies": {
    "@types/node": "^20.11.17",
    "tsx": "^4.7.1",
    "typescript": "^5.8.3"
  }
}
</file>

<file path="README.md">
```
npm install
npm run dev
```

```
open http://localhost:3000
```
</file>

<file path="src/config/env.ts">
import 'dotenv/config';

export const config = {
  port: Number(process.env.PORT) || 4000,
  faydaUrl: process.env.FAYDA_API_URL!,
  supabase: {
    url: process.env.SUPABASE_URL!,
    serviceKey: process.env.SUPABASE_SERVICE_ROLE_KEY!,
  },
};
</file>

<file path="src/index.ts">
import { serve } from '@hono/node-server';
import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { config } from './config/env.js';
import authRoutes from './routes/auth.js';

const app = new Hono();

// Middleware
app.use('/*', cors()); // Allow Mobile App to connect

// Routes
app.route('/auth', authRoutes);

// Health Check
app.get('/', (c) => {
  return c.json({ status: 'Civic Backend is Running ðŸš€' });
});

console.log(`Server is running on http://localhost:${config.port}`);

serve({
  fetch: app.fetch,
  port: config.port
});
</file>

<file path="src/services/fyda.ts">
import axios from 'axios';
import { config } from '../config/env.js';

export const FaydaService = {
  /**
   * Send FIN to National ID System to trigger OTP
   */
  requestOtp: async (fin: string) => {
    try {
      const { data } = await axios.post(`${config.faydaUrl}/api/auth/otp-request`, { fin });
      return data;
    } catch (error: any) {
      throw new Error(error.response?.data?.error || "Fayda API Error");
    }
  },

  /**
   * Verify OTP with National ID System and get KYC Data
   */
  verifyOtp: async (fin: string, otp: string) => {
    try {
      const { data } = await axios.post(`${config.faydaUrl}/api/kyc/verify`, { fin, otp });
      return data.kyc_data; // Return just the user info
    } catch (error: any) {
      throw new Error(error.response?.data?.error || "Fayda Validation Failed");
    }
  }
};
</file>

<file path="src/services/supabase.ts">
import { createClient } from '@supabase/supabase-js';
import { config } from '../config/env.js';


// We use the Service Role Key here so the backend has full access
export const supabaseAdmin = createClient(
  config.supabase.url,
  config.supabase.serviceKey
);
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "NodeNext",
    "strict": true,
    "verbatimModuleSyntax": true,
    "skipLibCheck": true,
    "types": [
      "node"
    ],
    "jsx": "react-jsx",
    "jsxImportSource": "hono/jsx",
    "outDir": "./dist"
  },
  "exclude": ["node_modules"]
}
</file>

<file path="src/routes/auth.ts">
import { Hono } from "hono";
import { supabaseAdmin } from "../services/supabase.js";
import { FaydaService } from "../services/fyda.js";

const auth = new Hono();

// 1. INITIATE REGISTRATION (Step 1)
// Mobile sends FIN -> We check DB -> We call Fayda -> Fayda sends SMS
auth.post("/initiate-register", async (c) => {
  const { fin } = await c.req.json();

  if (!fin || fin.length !== 12) return c.json({ error: "Invalid FIN" }, 400);

  // A. Check if user already exists in OUR Supabase DB
  const { data: existingUser } = await supabaseAdmin
    .from("profiles")
    .select("id")
    .eq("fin", fin)
    .single();

  if (existingUser) {
    return c.json({ error: "User already registered. Please Login." }, 409);
  }

  // B. Call Fayda to send OTP
  try {
    await FaydaService.requestOtp(fin);
    return c.json({ message: "OTP sent successfully" });
  } catch (err: any) {
    return c.json({ error: err.message }, 500);
  }
});



auth.post('/login', async (c) => {
  const { loginInput, password } = await c.req.json();
  const rawInput = (loginInput || "").trim();

  if (!rawInput || !password) return c.json({ error: "Missing credentials" }, 400);

  try {
    // A. FIND USER (By FIN or Phone)
    let profileData = null;
    
    // Check if input looks like a FIN
    if (/^\d{12}$/.test(rawInput)) {
      const { data } = await supabaseAdmin
        .from('profiles')
        .select('id, failed_login_attempts, locked_until') // Get security fields
        .eq('fin', rawInput)
        .maybeSingle();
      profileData = data;
    } else {
      // Check phone numbers
      let possibleNumbers = [rawInput];
      if (rawInput.startsWith('09')) possibleNumbers.push('+251' + rawInput.substring(1));
      else if (rawInput.startsWith('+2519')) possibleNumbers.push('0' + rawInput.substring(4));

      const { data } = await supabaseAdmin
        .from('profiles')
        .select('id, failed_login_attempts, locked_until') // Get security fields
        .in('phone_number', possibleNumbers)
        .maybeSingle();
      profileData = data;
    }

    if (!profileData) {
      // Security: Don't reveal if user exists or not, but strictly:
      return c.json({ error: "Invalid Login Credentials" }, 401);
    }

    // --- FR-01.10 CHECK LOCKOUT ---
    if (profileData.locked_until && new Date(profileData.locked_until) > new Date()) {
      const waitTime = Math.ceil((new Date(profileData.locked_until).getTime() - new Date().getTime()) / 60000);
      return c.json({ error: `Account locked. Try again in ${waitTime} minutes.` }, 403);
    }

    // B. GET EMAIL for Auth
    const { data: userData, error: userError } = await supabaseAdmin.auth.admin.getUserById(profileData.id);
    if (userError || !userData.user) return c.json({ error: "System Error" }, 500);

    // C. ATTEMPT LOGIN
    const { data, error } = await supabaseAdmin.auth.signInWithPassword({
      email: userData.user.email!,
      password: password,
    });

    if (error) {
      // --- LOGIN FAILED: INCREMENT COUNTER ---
      const newCount = (profileData.failed_login_attempts || 0) + 1;
      let updates: any = { failed_login_attempts: newCount };

      // Check if limit reached (5 attempts)
      if (newCount >= 5) {
        // Lock for 15 minutes
        const lockTime = new Date();
        lockTime.setMinutes(lockTime.getMinutes() + 15);
        updates.locked_until = lockTime;
      }

      await supabaseAdmin.from('profiles').update(updates).eq('id', profileData.id);

      if (newCount >= 5) {
        return c.json({ error: "Too many failed attempts. Account locked for 15 minutes." }, 403);
      } else {
        return c.json({ error: `Incorrect Password. (${5 - newCount} attempts remaining)` }, 401);
      }
    }

    // --- LOGIN SUCCESS: RESET COUNTERS ---
    await supabaseAdmin
      .from('profiles')
      .update({ failed_login_attempts: 0, locked_until: null })
      .eq('id', profileData.id);

    return c.json({ session: data.session, user: data.user });

  } catch (err: any) {
    return c.json({ error: err.message }, 500);
  }
});

// 2. COMPLETE REGISTRATION (Step 2 & 3)
// Mobile sends FIN + OTP + Password -> We verify Fayda -> We create Supabase User
auth.post("/complete-register", async (c) => {
  const { fin, otp, email, password } = await c.req.json();

  try {
    // A. Verify OTP with Fayda API
    const kycData = await FaydaService.verifyOtp(fin, otp);

    // B. Create Auth User in Supabase
    const { data: authData, error: authError } =
      await supabaseAdmin.auth.admin.createUser({
        email: email,
        password: password,
        email_confirm: true, // Auto-confirm email
        user_metadata: { full_name: kycData.personalIdentity.fullName },
      });

    if (authError) throw authError;

    // C. Save Profile to Postgres
    const { error: dbError } = await supabaseAdmin.from("profiles").insert({
      id: authData.user.id,
      fin: fin,
      full_name: kycData.personalIdentity.fullName,
      phone_number: kycData.personalIdentity.phone,
      dob: kycData.personalIdentity.dob,
      gender: kycData.personalIdentity.gender,
      photo_url: kycData.biometrics?.face || null,
      role: "citizen",
    });

    if (dbError) throw dbError;

    return c.json({ message: "Registration Successful", user: authData.user });
  } catch (err: any) {
    console.error(err);
    return c.json({ error: err.message || "Registration Failed" }, 400);
  }
});

// 3. RESET PASSWORD (FR-01.9)
// Uses Fayda OTP to verify identity, then Force-Updates Supabase Password
auth.post("/reset-password", async (c) => {
  const { fin, otp, newPassword } = await c.req.json();

  try {
    // A. Verify Identity via Fayda
    // (If OTP is correct, we know this is the real owner of the ID)
    await FaydaService.verifyOtp(fin, otp);

    // B. Find the Supabase User ID by FIN
    const { data: profile } = await supabaseAdmin
      .from("profiles")
      .select("id")
      .eq("fin", fin)
      .single();

    if (!profile) return c.json({ error: "User not found" }, 404);

    // C. Admin Force Update Password
    const { error: updateError } =
      await supabaseAdmin.auth.admin.updateUserById(profile.id, {
        password: newPassword,
      });

    if (updateError) throw updateError;

    return c.json({ message: "Password updated successfully" });
  } catch (err: any) {
    return c.json({ error: err.message || "Reset Failed" }, 400);
  }
});

auth.post("/initiate-reset", async (c) => {
  const { fin } = await c.req.json();
  if (!fin) return c.json({ error: "FIN required" }, 400);

  // A. Check if user EXISTS in Supabase
  const { data: user } = await supabaseAdmin
    .from("profiles")
    .select("id")
    .eq("fin", fin)
    .single();

  if (!user) {
    // Security: You can return generic "If user exists, OTP sent" to prevent enumeration,
    // but for this project, let's return a clear error.
    return c.json(
      { error: "No account found with this ID. Please Register." },
      404
    );
  }

  // B. Call Fayda to send OTP
  try {
    await FaydaService.requestOtp(fin);
    return c.json({ message: "OTP sent" });
  } catch (err: any) {
    return c.json({ error: err.message }, 500);
  }
});

export default auth;
</file>

</files>
